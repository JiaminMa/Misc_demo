
main.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <default_exception_handler-0x418>:
   0:	20008000 	.word	0x20008000
   4:	00000425 	.word	0x00000425
   8:	00000419 	.word	0x00000419
   c:	00000419 	.word	0x00000419
  10:	00000419 	.word	0x00000419
  14:	00000419 	.word	0x00000419
  18:	00000419 	.word	0x00000419
  1c:	00000419 	.word	0x00000419
  20:	00000419 	.word	0x00000419
  24:	00000419 	.word	0x00000419
  28:	00000419 	.word	0x00000419
  2c:	00000419 	.word	0x00000419
  30:	00000419 	.word	0x00000419
  34:	00000419 	.word	0x00000419
  38:	00000419 	.word	0x00000419
  3c:	00000419 	.word	0x00000419
  40:	00000419 	.word	0x00000419
  44:	00000419 	.word	0x00000419
  48:	00000419 	.word	0x00000419
  4c:	00000419 	.word	0x00000419
  50:	00000419 	.word	0x00000419
  54:	00000419 	.word	0x00000419
  58:	00000419 	.word	0x00000419
  5c:	00000419 	.word	0x00000419
  60:	00000419 	.word	0x00000419
  64:	00000419 	.word	0x00000419
  68:	00000419 	.word	0x00000419
  6c:	00000419 	.word	0x00000419
  70:	00000419 	.word	0x00000419
  74:	00000419 	.word	0x00000419
  78:	00000419 	.word	0x00000419
  7c:	00000419 	.word	0x00000419
  80:	00000419 	.word	0x00000419
  84:	00000419 	.word	0x00000419
  88:	00000419 	.word	0x00000419
  8c:	00000419 	.word	0x00000419
  90:	00000419 	.word	0x00000419
  94:	00000419 	.word	0x00000419
  98:	00000419 	.word	0x00000419
  9c:	00000419 	.word	0x00000419
  a0:	00000419 	.word	0x00000419
  a4:	00000419 	.word	0x00000419
  a8:	00000419 	.word	0x00000419
  ac:	00000419 	.word	0x00000419
  b0:	00000419 	.word	0x00000419
  b4:	00000419 	.word	0x00000419
  b8:	00000419 	.word	0x00000419
  bc:	00000419 	.word	0x00000419
  c0:	00000419 	.word	0x00000419
  c4:	00000419 	.word	0x00000419
  c8:	00000419 	.word	0x00000419
  cc:	00000419 	.word	0x00000419
  d0:	00000419 	.word	0x00000419
  d4:	00000419 	.word	0x00000419
  d8:	00000419 	.word	0x00000419
  dc:	00000419 	.word	0x00000419
  e0:	00000419 	.word	0x00000419
  e4:	00000419 	.word	0x00000419
  e8:	00000419 	.word	0x00000419
  ec:	00000419 	.word	0x00000419
  f0:	00000419 	.word	0x00000419
  f4:	00000419 	.word	0x00000419
  f8:	00000419 	.word	0x00000419
  fc:	00000419 	.word	0x00000419
 100:	00000419 	.word	0x00000419
 104:	00000419 	.word	0x00000419
 108:	00000419 	.word	0x00000419
 10c:	00000419 	.word	0x00000419
 110:	00000419 	.word	0x00000419
 114:	00000419 	.word	0x00000419
 118:	00000419 	.word	0x00000419
 11c:	00000419 	.word	0x00000419
 120:	00000419 	.word	0x00000419
 124:	00000419 	.word	0x00000419
 128:	00000419 	.word	0x00000419
 12c:	00000419 	.word	0x00000419
 130:	00000419 	.word	0x00000419
 134:	00000419 	.word	0x00000419
 138:	00000419 	.word	0x00000419
 13c:	00000419 	.word	0x00000419
 140:	00000419 	.word	0x00000419
 144:	00000419 	.word	0x00000419
 148:	00000419 	.word	0x00000419
 14c:	00000419 	.word	0x00000419
 150:	00000419 	.word	0x00000419
 154:	00000419 	.word	0x00000419
 158:	00000419 	.word	0x00000419
 15c:	00000419 	.word	0x00000419
 160:	00000419 	.word	0x00000419
 164:	00000419 	.word	0x00000419
 168:	00000419 	.word	0x00000419
 16c:	00000419 	.word	0x00000419
 170:	00000419 	.word	0x00000419
 174:	00000419 	.word	0x00000419
 178:	00000419 	.word	0x00000419
 17c:	00000419 	.word	0x00000419
 180:	00000419 	.word	0x00000419
 184:	00000419 	.word	0x00000419
 188:	00000419 	.word	0x00000419
 18c:	00000419 	.word	0x00000419
 190:	00000419 	.word	0x00000419
 194:	00000419 	.word	0x00000419
 198:	00000419 	.word	0x00000419
 19c:	00000419 	.word	0x00000419
 1a0:	00000419 	.word	0x00000419
 1a4:	00000419 	.word	0x00000419
 1a8:	00000419 	.word	0x00000419
 1ac:	00000419 	.word	0x00000419
 1b0:	00000419 	.word	0x00000419
 1b4:	00000419 	.word	0x00000419
 1b8:	00000419 	.word	0x00000419
 1bc:	00000419 	.word	0x00000419
 1c0:	00000419 	.word	0x00000419
 1c4:	00000419 	.word	0x00000419
 1c8:	00000419 	.word	0x00000419
 1cc:	00000419 	.word	0x00000419
 1d0:	00000419 	.word	0x00000419
 1d4:	00000419 	.word	0x00000419
 1d8:	00000419 	.word	0x00000419
 1dc:	00000419 	.word	0x00000419
 1e0:	00000419 	.word	0x00000419
 1e4:	00000419 	.word	0x00000419
 1e8:	00000419 	.word	0x00000419
 1ec:	00000419 	.word	0x00000419
 1f0:	00000419 	.word	0x00000419
 1f4:	00000419 	.word	0x00000419
 1f8:	00000419 	.word	0x00000419
 1fc:	00000419 	.word	0x00000419
 200:	00000419 	.word	0x00000419
 204:	00000419 	.word	0x00000419
 208:	00000419 	.word	0x00000419
 20c:	00000419 	.word	0x00000419
 210:	00000419 	.word	0x00000419
 214:	00000419 	.word	0x00000419
 218:	00000419 	.word	0x00000419
 21c:	00000419 	.word	0x00000419
 220:	00000419 	.word	0x00000419
 224:	00000419 	.word	0x00000419
 228:	00000419 	.word	0x00000419
 22c:	00000419 	.word	0x00000419
 230:	00000419 	.word	0x00000419
 234:	00000419 	.word	0x00000419
 238:	00000419 	.word	0x00000419
 23c:	00000419 	.word	0x00000419
 240:	00000419 	.word	0x00000419
 244:	00000419 	.word	0x00000419
 248:	00000419 	.word	0x00000419
 24c:	00000419 	.word	0x00000419
 250:	00000419 	.word	0x00000419
 254:	00000419 	.word	0x00000419
 258:	00000419 	.word	0x00000419
 25c:	00000419 	.word	0x00000419
 260:	00000419 	.word	0x00000419
 264:	00000419 	.word	0x00000419
 268:	00000419 	.word	0x00000419
 26c:	00000419 	.word	0x00000419
 270:	00000419 	.word	0x00000419
 274:	00000419 	.word	0x00000419
 278:	00000419 	.word	0x00000419
 27c:	00000419 	.word	0x00000419
 280:	00000419 	.word	0x00000419
 284:	00000419 	.word	0x00000419
 288:	00000419 	.word	0x00000419
 28c:	00000419 	.word	0x00000419
 290:	00000419 	.word	0x00000419
 294:	00000419 	.word	0x00000419
 298:	00000419 	.word	0x00000419
 29c:	00000419 	.word	0x00000419
 2a0:	00000419 	.word	0x00000419
 2a4:	00000419 	.word	0x00000419
 2a8:	00000419 	.word	0x00000419
 2ac:	00000419 	.word	0x00000419
 2b0:	00000419 	.word	0x00000419
 2b4:	00000419 	.word	0x00000419
 2b8:	00000419 	.word	0x00000419
 2bc:	00000419 	.word	0x00000419
 2c0:	00000419 	.word	0x00000419
 2c4:	00000419 	.word	0x00000419
 2c8:	00000419 	.word	0x00000419
 2cc:	00000419 	.word	0x00000419
 2d0:	00000419 	.word	0x00000419
 2d4:	00000419 	.word	0x00000419
 2d8:	00000419 	.word	0x00000419
 2dc:	00000419 	.word	0x00000419
 2e0:	00000419 	.word	0x00000419
 2e4:	00000419 	.word	0x00000419
 2e8:	00000419 	.word	0x00000419
 2ec:	00000419 	.word	0x00000419
 2f0:	00000419 	.word	0x00000419
 2f4:	00000419 	.word	0x00000419
 2f8:	00000419 	.word	0x00000419
 2fc:	00000419 	.word	0x00000419
 300:	00000419 	.word	0x00000419
 304:	00000419 	.word	0x00000419
 308:	00000419 	.word	0x00000419
 30c:	00000419 	.word	0x00000419
 310:	00000419 	.word	0x00000419
 314:	00000419 	.word	0x00000419
 318:	00000419 	.word	0x00000419
 31c:	00000419 	.word	0x00000419
 320:	00000419 	.word	0x00000419
 324:	00000419 	.word	0x00000419
 328:	00000419 	.word	0x00000419
 32c:	00000419 	.word	0x00000419
 330:	00000419 	.word	0x00000419
 334:	00000419 	.word	0x00000419
 338:	00000419 	.word	0x00000419
 33c:	00000419 	.word	0x00000419
 340:	00000419 	.word	0x00000419
 344:	00000419 	.word	0x00000419
 348:	00000419 	.word	0x00000419
 34c:	00000419 	.word	0x00000419
 350:	00000419 	.word	0x00000419
 354:	00000419 	.word	0x00000419
 358:	00000419 	.word	0x00000419
 35c:	00000419 	.word	0x00000419
 360:	00000419 	.word	0x00000419
 364:	00000419 	.word	0x00000419
 368:	00000419 	.word	0x00000419
 36c:	00000419 	.word	0x00000419
 370:	00000419 	.word	0x00000419
 374:	00000419 	.word	0x00000419
 378:	00000419 	.word	0x00000419
 37c:	00000419 	.word	0x00000419
 380:	00000419 	.word	0x00000419
 384:	00000419 	.word	0x00000419
 388:	00000419 	.word	0x00000419
 38c:	00000419 	.word	0x00000419
 390:	00000419 	.word	0x00000419
 394:	00000419 	.word	0x00000419
 398:	00000419 	.word	0x00000419
 39c:	00000419 	.word	0x00000419
 3a0:	00000419 	.word	0x00000419
 3a4:	00000419 	.word	0x00000419
 3a8:	00000419 	.word	0x00000419
 3ac:	00000419 	.word	0x00000419
 3b0:	00000419 	.word	0x00000419
 3b4:	00000419 	.word	0x00000419
 3b8:	00000419 	.word	0x00000419
 3bc:	00000419 	.word	0x00000419
 3c0:	00000419 	.word	0x00000419
 3c4:	00000419 	.word	0x00000419
 3c8:	00000419 	.word	0x00000419
 3cc:	00000419 	.word	0x00000419
 3d0:	00000419 	.word	0x00000419
 3d4:	00000419 	.word	0x00000419
 3d8:	00000419 	.word	0x00000419
 3dc:	00000419 	.word	0x00000419
 3e0:	00000419 	.word	0x00000419
 3e4:	00000419 	.word	0x00000419
 3e8:	00000419 	.word	0x00000419
 3ec:	00000419 	.word	0x00000419
 3f0:	00000419 	.word	0x00000419
 3f4:	00000419 	.word	0x00000419
 3f8:	00000419 	.word	0x00000419
 3fc:	00000419 	.word	0x00000419
 400:	00000419 	.word	0x00000419
 404:	00000419 	.word	0x00000419
 408:	00000419 	.word	0x00000419
 40c:	00000419 	.word	0x00000419
 410:	00000419 	.word	0x00000419
 414:	00000419 	.word	0x00000419

00000418 <default_exception_handler>:
extern void easy_printf(const char *fmt, ...);

void default_exception_handler(void)
{
 418:	b480      	push	{r7}
 41a:	af00      	add	r7, sp, #0
}
 41c:	bf00      	nop
 41e:	46bd      	mov	sp, r7
 420:	bc80      	pop	{r7}
 422:	4770      	bx	lr

00000424 <main>:

int main()
{
 424:	b580      	push	{r7, lr}
 426:	b082      	sub	sp, #8
 428:	af00      	add	r7, sp, #0

    unsigned int *add =(unsigned int *)0x0;
 42a:	2300      	movs	r3, #0
 42c:	607b      	str	r3, [r7, #4]
    *add = 1;
 42e:	687b      	ldr	r3, [r7, #4]
 430:	2201      	movs	r2, #1
 432:	601a      	str	r2, [r3, #0]
    add = (unsigned int *)0x1ffe0000;
 434:	4b07      	ldr	r3, [pc, #28]	; (454 <main+0x30>)
 436:	607b      	str	r3, [r7, #4]
    *add = 2;
 438:	687b      	ldr	r3, [r7, #4]
 43a:	2202      	movs	r2, #2
 43c:	601a      	str	r2, [r3, #0]

    add = (unsigned int *)0x80000000;
 43e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 442:	607b      	str	r3, [r7, #4]
    *add = 3;
 444:	687b      	ldr	r3, [r7, #4]
 446:	2203      	movs	r2, #3
 448:	601a      	str	r2, [r3, #0]

    easy_printf("Hello Cortex M\n");
 44a:	4803      	ldr	r0, [pc, #12]	; (458 <main+0x34>)
 44c:	f000 fa52 	bl	8f4 <easy_printf>
    while(1);
 450:	e7fe      	b.n	450 <main+0x2c>
 452:	bf00      	nop
 454:	1ffe0000 	.word	0x1ffe0000
 458:	00000dbc 	.word	0x00000dbc

0000045c <send_char>:
#include <stdint.h>

volatile uint32_t * const UART0DR = (uint32_t *)0x4000C000;

char send_char(uint8_t *ch)
{
 45c:	b480      	push	{r7}
 45e:	b083      	sub	sp, #12
 460:	af00      	add	r7, sp, #0
 462:	6078      	str	r0, [r7, #4]
    *UART0DR = *ch;
 464:	4a05      	ldr	r2, [pc, #20]	; (47c <send_char+0x20>)
 466:	687b      	ldr	r3, [r7, #4]
 468:	781b      	ldrb	r3, [r3, #0]
 46a:	6013      	str	r3, [r2, #0]
    return *ch;
 46c:	687b      	ldr	r3, [r7, #4]
 46e:	781b      	ldrb	r3, [r3, #0]
}
 470:	4618      	mov	r0, r3
 472:	370c      	adds	r7, #12
 474:	46bd      	mov	sp, r7
 476:	bc80      	pop	{r7}
 478:	4770      	bx	lr
 47a:	bf00      	nop
 47c:	4000c000 	.word	0x4000c000

00000480 <is_dec_asc>:
    { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
const char upper_hex_asc_table[16] =
    { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

int is_dec_asc(char ch)
{
 480:	b480      	push	{r7}
 482:	b085      	sub	sp, #20
 484:	af00      	add	r7, sp, #0
 486:	4603      	mov	r3, r0
 488:	71fb      	strb	r3, [r7, #7]
    uint32_t i;
    for (i = 0; i < 10; i++) {
 48a:	2300      	movs	r3, #0
 48c:	60fb      	str	r3, [r7, #12]
 48e:	e00b      	b.n	4a8 <is_dec_asc+0x28>
        if (ch == hex_asc_table[i])
 490:	4a0a      	ldr	r2, [pc, #40]	; (4bc <is_dec_asc+0x3c>)
 492:	68fb      	ldr	r3, [r7, #12]
 494:	4413      	add	r3, r2
 496:	781b      	ldrb	r3, [r3, #0]
 498:	79fa      	ldrb	r2, [r7, #7]
 49a:	429a      	cmp	r2, r3
 49c:	d101      	bne.n	4a2 <is_dec_asc+0x22>
            return 1;
 49e:	2301      	movs	r3, #1
 4a0:	e006      	b.n	4b0 <is_dec_asc+0x30>
    for (i = 0; i < 10; i++) {
 4a2:	68fb      	ldr	r3, [r7, #12]
 4a4:	3301      	adds	r3, #1
 4a6:	60fb      	str	r3, [r7, #12]
 4a8:	68fb      	ldr	r3, [r7, #12]
 4aa:	2b09      	cmp	r3, #9
 4ac:	d9f0      	bls.n	490 <is_dec_asc+0x10>
    }

    return 0;
 4ae:	2300      	movs	r3, #0
}
 4b0:	4618      	mov	r0, r3
 4b2:	3714      	adds	r7, #20
 4b4:	46bd      	mov	sp, r7
 4b6:	bc80      	pop	{r7}
 4b8:	4770      	bx	lr
 4ba:	bf00      	nop
 4bc:	00000dd0 	.word	0x00000dd0

000004c0 <is_asc>:

int is_asc(char ch)
{
 4c0:	b480      	push	{r7}
 4c2:	b083      	sub	sp, #12
 4c4:	af00      	add	r7, sp, #0
 4c6:	4603      	mov	r3, r0
 4c8:	71fb      	strb	r3, [r7, #7]
    return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
 4ca:	79fb      	ldrb	r3, [r7, #7]
 4cc:	2b40      	cmp	r3, #64	; 0x40
 4ce:	d902      	bls.n	4d6 <is_asc+0x16>
 4d0:	79fb      	ldrb	r3, [r7, #7]
 4d2:	2b5a      	cmp	r3, #90	; 0x5a
 4d4:	d905      	bls.n	4e2 <is_asc+0x22>
 4d6:	79fb      	ldrb	r3, [r7, #7]
 4d8:	2b60      	cmp	r3, #96	; 0x60
 4da:	d904      	bls.n	4e6 <is_asc+0x26>
 4dc:	79fb      	ldrb	r3, [r7, #7]
 4de:	2b7a      	cmp	r3, #122	; 0x7a
 4e0:	d801      	bhi.n	4e6 <is_asc+0x26>
 4e2:	2301      	movs	r3, #1
 4e4:	e000      	b.n	4e8 <is_asc+0x28>
 4e6:	2300      	movs	r3, #0
}
 4e8:	4618      	mov	r0, r3
 4ea:	370c      	adds	r7, #12
 4ec:	46bd      	mov	sp, r7
 4ee:	bc80      	pop	{r7}
 4f0:	4770      	bx	lr

000004f2 <is_hex_asc>:

int is_hex_asc(char ch)
{
 4f2:	b480      	push	{r7}
 4f4:	b083      	sub	sp, #12
 4f6:	af00      	add	r7, sp, #0
 4f8:	4603      	mov	r3, r0
 4fa:	71fb      	strb	r3, [r7, #7]
    return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f');
 4fc:	79fb      	ldrb	r3, [r7, #7]
 4fe:	2b2f      	cmp	r3, #47	; 0x2f
 500:	d902      	bls.n	508 <is_hex_asc+0x16>
 502:	79fb      	ldrb	r3, [r7, #7]
 504:	2b39      	cmp	r3, #57	; 0x39
 506:	d90b      	bls.n	520 <is_hex_asc+0x2e>
 508:	79fb      	ldrb	r3, [r7, #7]
 50a:	2b40      	cmp	r3, #64	; 0x40
 50c:	d902      	bls.n	514 <is_hex_asc+0x22>
 50e:	79fb      	ldrb	r3, [r7, #7]
 510:	2b46      	cmp	r3, #70	; 0x46
 512:	d905      	bls.n	520 <is_hex_asc+0x2e>
 514:	79fb      	ldrb	r3, [r7, #7]
 516:	2b60      	cmp	r3, #96	; 0x60
 518:	d904      	bls.n	524 <is_hex_asc+0x32>
 51a:	79fb      	ldrb	r3, [r7, #7]
 51c:	2b66      	cmp	r3, #102	; 0x66
 51e:	d801      	bhi.n	524 <is_hex_asc+0x32>
 520:	2301      	movs	r3, #1
 522:	e000      	b.n	526 <is_hex_asc+0x34>
 524:	2300      	movs	r3, #0
}
 526:	4618      	mov	r0, r3
 528:	370c      	adds	r7, #12
 52a:	46bd      	mov	sp, r7
 52c:	bc80      	pop	{r7}
 52e:	4770      	bx	lr

00000530 <printf_char>:

int printf_char(char ch)
{
 530:	b580      	push	{r7, lr}
 532:	b084      	sub	sp, #16
 534:	af00      	add	r7, sp, #0
 536:	4603      	mov	r3, r0
 538:	71fb      	strb	r3, [r7, #7]
    uint8_t c1 = (uint8_t)'\r';
 53a:	230d      	movs	r3, #13
 53c:	73fb      	strb	r3, [r7, #15]
    uint8_t c2 = 0;
 53e:	2300      	movs	r3, #0
 540:	73bb      	strb	r3, [r7, #14]

    c2 = (uint8_t)ch;
 542:	79fb      	ldrb	r3, [r7, #7]
 544:	73bb      	strb	r3, [r7, #14]

    send_char(&c2);
 546:	f107 030e 	add.w	r3, r7, #14
 54a:	4618      	mov	r0, r3
 54c:	f7ff ff86 	bl	45c <send_char>

    if (((uint8_t)'\n') == c2) {
 550:	7bbb      	ldrb	r3, [r7, #14]
 552:	2b0a      	cmp	r3, #10
 554:	d104      	bne.n	560 <printf_char+0x30>
        send_char(&c1);
 556:	f107 030f 	add.w	r3, r7, #15
 55a:	4618      	mov	r0, r3
 55c:	f7ff ff7e 	bl	45c <send_char>
    }

    return 0;
 560:	2300      	movs	r3, #0
}
 562:	4618      	mov	r0, r3
 564:	3710      	adds	r7, #16
 566:	46bd      	mov	sp, r7
 568:	bd80      	pop	{r7, pc}

0000056a <printf_str>:

int printf_str(char *str)
{
 56a:	b580      	push	{r7, lr}
 56c:	b082      	sub	sp, #8
 56e:	af00      	add	r7, sp, #0
 570:	6078      	str	r0, [r7, #4]
    while (str && (*str != (char)'\0')) {
 572:	e007      	b.n	584 <printf_str+0x1a>
        printf_char(*str);
 574:	687b      	ldr	r3, [r7, #4]
 576:	781b      	ldrb	r3, [r3, #0]
 578:	4618      	mov	r0, r3
 57a:	f7ff ffd9 	bl	530 <printf_char>
        str++;
 57e:	687b      	ldr	r3, [r7, #4]
 580:	3301      	adds	r3, #1
 582:	607b      	str	r3, [r7, #4]
    while (str && (*str != (char)'\0')) {
 584:	687b      	ldr	r3, [r7, #4]
 586:	2b00      	cmp	r3, #0
 588:	d003      	beq.n	592 <printf_str+0x28>
 58a:	687b      	ldr	r3, [r7, #4]
 58c:	781b      	ldrb	r3, [r3, #0]
 58e:	2b00      	cmp	r3, #0
 590:	d1f0      	bne.n	574 <printf_str+0xa>
    }

    return 0;
 592:	2300      	movs	r3, #0
}
 594:	4618      	mov	r0, r3
 596:	3708      	adds	r7, #8
 598:	46bd      	mov	sp, r7
 59a:	bd80      	pop	{r7, pc}

0000059c <printf_hex>:

int printf_hex(uint32_t val, uint32_t width)
{
 59c:	b580      	push	{r7, lr}
 59e:	b084      	sub	sp, #16
 5a0:	af00      	add	r7, sp, #0
 5a2:	6078      	str	r0, [r7, #4]
 5a4:	6039      	str	r1, [r7, #0]
    int i = 0;
 5a6:	2300      	movs	r3, #0
 5a8:	60fb      	str	r3, [r7, #12]
    char hex_val = 0, asc = 0;
 5aa:	2300      	movs	r3, #0
 5ac:	72fb      	strb	r3, [r7, #11]
 5ae:	2300      	movs	r3, #0
 5b0:	72bb      	strb	r3, [r7, #10]

    if ((width > 8) || (width == 0))
 5b2:	683b      	ldr	r3, [r7, #0]
 5b4:	2b08      	cmp	r3, #8
 5b6:	d802      	bhi.n	5be <printf_hex+0x22>
 5b8:	683b      	ldr	r3, [r7, #0]
 5ba:	2b00      	cmp	r3, #0
 5bc:	d101      	bne.n	5c2 <printf_hex+0x26>
        width = 8;
 5be:	2308      	movs	r3, #8
 5c0:	603b      	str	r3, [r7, #0]

    for (i = width - 1; i >= 0; i--) {
 5c2:	683b      	ldr	r3, [r7, #0]
 5c4:	3b01      	subs	r3, #1
 5c6:	60fb      	str	r3, [r7, #12]
 5c8:	e017      	b.n	5fa <printf_hex+0x5e>
        hex_val = (val & (0x0F << (i << 2))) >> (i << 2);
 5ca:	68fb      	ldr	r3, [r7, #12]
 5cc:	009b      	lsls	r3, r3, #2
 5ce:	220f      	movs	r2, #15
 5d0:	fa02 f303 	lsl.w	r3, r2, r3
 5d4:	461a      	mov	r2, r3
 5d6:	687b      	ldr	r3, [r7, #4]
 5d8:	401a      	ands	r2, r3
 5da:	68fb      	ldr	r3, [r7, #12]
 5dc:	009b      	lsls	r3, r3, #2
 5de:	fa22 f303 	lsr.w	r3, r2, r3
 5e2:	72fb      	strb	r3, [r7, #11]
        asc = hex_asc_table[(int)hex_val];
 5e4:	7afb      	ldrb	r3, [r7, #11]
 5e6:	4a09      	ldr	r2, [pc, #36]	; (60c <printf_hex+0x70>)
 5e8:	5cd3      	ldrb	r3, [r2, r3]
 5ea:	72bb      	strb	r3, [r7, #10]
        printf_char(asc);
 5ec:	7abb      	ldrb	r3, [r7, #10]
 5ee:	4618      	mov	r0, r3
 5f0:	f7ff ff9e 	bl	530 <printf_char>
    for (i = width - 1; i >= 0; i--) {
 5f4:	68fb      	ldr	r3, [r7, #12]
 5f6:	3b01      	subs	r3, #1
 5f8:	60fb      	str	r3, [r7, #12]
 5fa:	68fb      	ldr	r3, [r7, #12]
 5fc:	2b00      	cmp	r3, #0
 5fe:	dae4      	bge.n	5ca <printf_hex+0x2e>
    }

    return 0;
 600:	2300      	movs	r3, #0
}
 602:	4618      	mov	r0, r3
 604:	3710      	adds	r7, #16
 606:	46bd      	mov	sp, r7
 608:	bd80      	pop	{r7, pc}
 60a:	bf00      	nop
 60c:	00000dd0 	.word	0x00000dd0

00000610 <printf_hex_upper>:

int printf_hex_upper(uint32_t val, uint32_t width)
{
 610:	b580      	push	{r7, lr}
 612:	b084      	sub	sp, #16
 614:	af00      	add	r7, sp, #0
 616:	6078      	str	r0, [r7, #4]
 618:	6039      	str	r1, [r7, #0]
    int i = 0;
 61a:	2300      	movs	r3, #0
 61c:	60fb      	str	r3, [r7, #12]
    char hex_val = 0, asc = 0;
 61e:	2300      	movs	r3, #0
 620:	72fb      	strb	r3, [r7, #11]
 622:	2300      	movs	r3, #0
 624:	72bb      	strb	r3, [r7, #10]

    if ((width > 8) || (width == 0))
 626:	683b      	ldr	r3, [r7, #0]
 628:	2b08      	cmp	r3, #8
 62a:	d802      	bhi.n	632 <printf_hex_upper+0x22>
 62c:	683b      	ldr	r3, [r7, #0]
 62e:	2b00      	cmp	r3, #0
 630:	d101      	bne.n	636 <printf_hex_upper+0x26>
        width = 8;
 632:	2308      	movs	r3, #8
 634:	603b      	str	r3, [r7, #0]

    for (i = width - 1; i >= 0; i--) {
 636:	683b      	ldr	r3, [r7, #0]
 638:	3b01      	subs	r3, #1
 63a:	60fb      	str	r3, [r7, #12]
 63c:	e017      	b.n	66e <printf_hex_upper+0x5e>
        hex_val = (val & (0x0F << (i << 2))) >> (i << 2);
 63e:	68fb      	ldr	r3, [r7, #12]
 640:	009b      	lsls	r3, r3, #2
 642:	220f      	movs	r2, #15
 644:	fa02 f303 	lsl.w	r3, r2, r3
 648:	461a      	mov	r2, r3
 64a:	687b      	ldr	r3, [r7, #4]
 64c:	401a      	ands	r2, r3
 64e:	68fb      	ldr	r3, [r7, #12]
 650:	009b      	lsls	r3, r3, #2
 652:	fa22 f303 	lsr.w	r3, r2, r3
 656:	72fb      	strb	r3, [r7, #11]
        asc = upper_hex_asc_table[(int)hex_val];
 658:	7afb      	ldrb	r3, [r7, #11]
 65a:	4a09      	ldr	r2, [pc, #36]	; (680 <printf_hex_upper+0x70>)
 65c:	5cd3      	ldrb	r3, [r2, r3]
 65e:	72bb      	strb	r3, [r7, #10]
        printf_char(asc);
 660:	7abb      	ldrb	r3, [r7, #10]
 662:	4618      	mov	r0, r3
 664:	f7ff ff64 	bl	530 <printf_char>
    for (i = width - 1; i >= 0; i--) {
 668:	68fb      	ldr	r3, [r7, #12]
 66a:	3b01      	subs	r3, #1
 66c:	60fb      	str	r3, [r7, #12]
 66e:	68fb      	ldr	r3, [r7, #12]
 670:	2b00      	cmp	r3, #0
 672:	dae4      	bge.n	63e <printf_hex_upper+0x2e>
    }

    return 0;
 674:	2300      	movs	r3, #0
}
 676:	4618      	mov	r0, r3
 678:	3710      	adds	r7, #16
 67a:	46bd      	mov	sp, r7
 67c:	bd80      	pop	{r7, pc}
 67e:	bf00      	nop
 680:	00000de0 	.word	0x00000de0

00000684 <printf_dec>:
#else
const uint32_t hex_weight_value_table[] =
    { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000 };

int printf_dec(uint32_t val)
{
 684:	b580      	push	{r7, lr}
 686:	b086      	sub	sp, #24
 688:	af00      	add	r7, sp, #0
 68a:	6078      	str	r0, [r7, #4]
    uint32_t i = 0;
 68c:	2300      	movs	r3, #0
 68e:	617b      	str	r3, [r7, #20]
    uint32_t tmp = 1, tmp_w = 1;
 690:	2301      	movs	r3, #1
 692:	613b      	str	r3, [r7, #16]
 694:	2301      	movs	r3, #1
 696:	60fb      	str	r3, [r7, #12]
    char asc = 0;
 698:	2300      	movs	r3, #0
 69a:	72fb      	strb	r3, [r7, #11]

    /* Figure out the digitals */
    while (1) {
        tmp = (tmp << 3) + (tmp << 1);  // tmp *= 10;
 69c:	693b      	ldr	r3, [r7, #16]
 69e:	00da      	lsls	r2, r3, #3
 6a0:	693b      	ldr	r3, [r7, #16]
 6a2:	005b      	lsls	r3, r3, #1
 6a4:	4413      	add	r3, r2
 6a6:	613b      	str	r3, [r7, #16]
        i++;
 6a8:	697b      	ldr	r3, [r7, #20]
 6aa:	3301      	adds	r3, #1
 6ac:	617b      	str	r3, [r7, #20]
        if (tmp > val) {
 6ae:	693a      	ldr	r2, [r7, #16]
 6b0:	687b      	ldr	r3, [r7, #4]
 6b2:	429a      	cmp	r2, r3
 6b4:	d800      	bhi.n	6b8 <printf_dec+0x34>
        tmp = (tmp << 3) + (tmp << 1);  // tmp *= 10;
 6b6:	e7f1      	b.n	69c <printf_dec+0x18>
            break;
 6b8:	bf00      	nop
        }
    }

    if (i > 8) {
 6ba:	697b      	ldr	r3, [r7, #20]
 6bc:	2b08      	cmp	r3, #8
 6be:	f240 810c 	bls.w	8da <printf_dec+0x256>
        return -1;
 6c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 6c6:	e10d      	b.n	8e4 <printf_dec+0x260>
    }

    while (i > 0) {
        if (val >= ((hex_weight_value_table[i - 1] << 3) + hex_weight_value_table[i - 1])) {    //<=9xxx
 6c8:	697b      	ldr	r3, [r7, #20]
 6ca:	3b01      	subs	r3, #1
 6cc:	4a87      	ldr	r2, [pc, #540]	; (8ec <printf_dec+0x268>)
 6ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 6d2:	00da      	lsls	r2, r3, #3
 6d4:	697b      	ldr	r3, [r7, #20]
 6d6:	3b01      	subs	r3, #1
 6d8:	4984      	ldr	r1, [pc, #528]	; (8ec <printf_dec+0x268>)
 6da:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 6de:	441a      	add	r2, r3
 6e0:	687b      	ldr	r3, [r7, #4]
 6e2:	429a      	cmp	r2, r3
 6e4:	d80f      	bhi.n	706 <printf_dec+0x82>
            tmp = 9;
 6e6:	2309      	movs	r3, #9
 6e8:	613b      	str	r3, [r7, #16]
            tmp_w = (hex_weight_value_table[i - 1] << 3) + hex_weight_value_table[i - 1];
 6ea:	697b      	ldr	r3, [r7, #20]
 6ec:	3b01      	subs	r3, #1
 6ee:	4a7f      	ldr	r2, [pc, #508]	; (8ec <printf_dec+0x268>)
 6f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 6f4:	00da      	lsls	r2, r3, #3
 6f6:	697b      	ldr	r3, [r7, #20]
 6f8:	3b01      	subs	r3, #1
 6fa:	497c      	ldr	r1, [pc, #496]	; (8ec <printf_dec+0x268>)
 6fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 700:	4413      	add	r3, r2
 702:	60fb      	str	r3, [r7, #12]
 704:	e0d9      	b.n	8ba <printf_dec+0x236>
        } else if (val >= (hex_weight_value_table[i - 1] << 3)) {   //8xxx
 706:	697b      	ldr	r3, [r7, #20]
 708:	3b01      	subs	r3, #1
 70a:	4a78      	ldr	r2, [pc, #480]	; (8ec <printf_dec+0x268>)
 70c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 710:	00da      	lsls	r2, r3, #3
 712:	687b      	ldr	r3, [r7, #4]
 714:	429a      	cmp	r2, r3
 716:	d809      	bhi.n	72c <printf_dec+0xa8>
            tmp = 8;
 718:	2308      	movs	r3, #8
 71a:	613b      	str	r3, [r7, #16]
            tmp_w = hex_weight_value_table[i - 1] << 3;
 71c:	697b      	ldr	r3, [r7, #20]
 71e:	3b01      	subs	r3, #1
 720:	4a72      	ldr	r2, [pc, #456]	; (8ec <printf_dec+0x268>)
 722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 726:	00db      	lsls	r3, r3, #3
 728:	60fb      	str	r3, [r7, #12]
 72a:	e0c6      	b.n	8ba <printf_dec+0x236>
        } else if (val >=
                   ((hex_weight_value_table[i - 1] << 2) + (hex_weight_value_table[i - 1] << 1) +
 72c:	697b      	ldr	r3, [r7, #20]
 72e:	3b01      	subs	r3, #1
 730:	4a6e      	ldr	r2, [pc, #440]	; (8ec <printf_dec+0x268>)
 732:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 736:	009a      	lsls	r2, r3, #2
 738:	697b      	ldr	r3, [r7, #20]
 73a:	3b01      	subs	r3, #1
 73c:	496b      	ldr	r1, [pc, #428]	; (8ec <printf_dec+0x268>)
 73e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 742:	005b      	lsls	r3, r3, #1
 744:	441a      	add	r2, r3
                    hex_weight_value_table[i - 1])) {
 746:	697b      	ldr	r3, [r7, #20]
 748:	3b01      	subs	r3, #1
 74a:	4968      	ldr	r1, [pc, #416]	; (8ec <printf_dec+0x268>)
 74c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                   ((hex_weight_value_table[i - 1] << 2) + (hex_weight_value_table[i - 1] << 1) +
 750:	441a      	add	r2, r3
        } else if (val >=
 752:	687b      	ldr	r3, [r7, #4]
 754:	429a      	cmp	r2, r3
 756:	d816      	bhi.n	786 <printf_dec+0x102>
            tmp = 7;
 758:	2307      	movs	r3, #7
 75a:	613b      	str	r3, [r7, #16]
            tmp_w =
                (hex_weight_value_table[i - 1] << 2) + (hex_weight_value_table[i - 1] << 1) +
 75c:	697b      	ldr	r3, [r7, #20]
 75e:	3b01      	subs	r3, #1
 760:	4a62      	ldr	r2, [pc, #392]	; (8ec <printf_dec+0x268>)
 762:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 766:	009a      	lsls	r2, r3, #2
 768:	697b      	ldr	r3, [r7, #20]
 76a:	3b01      	subs	r3, #1
 76c:	495f      	ldr	r1, [pc, #380]	; (8ec <printf_dec+0x268>)
 76e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 772:	005b      	lsls	r3, r3, #1
 774:	441a      	add	r2, r3
                hex_weight_value_table[i - 1];
 776:	697b      	ldr	r3, [r7, #20]
 778:	3b01      	subs	r3, #1
 77a:	495c      	ldr	r1, [pc, #368]	; (8ec <printf_dec+0x268>)
 77c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
            tmp_w =
 780:	4413      	add	r3, r2
 782:	60fb      	str	r3, [r7, #12]
 784:	e099      	b.n	8ba <printf_dec+0x236>
        } else if (val >=
                   ((hex_weight_value_table[i - 1] << 2) + (hex_weight_value_table[i - 1] << 1))) {
 786:	697b      	ldr	r3, [r7, #20]
 788:	3b01      	subs	r3, #1
 78a:	4a58      	ldr	r2, [pc, #352]	; (8ec <printf_dec+0x268>)
 78c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 790:	009a      	lsls	r2, r3, #2
 792:	697b      	ldr	r3, [r7, #20]
 794:	3b01      	subs	r3, #1
 796:	4955      	ldr	r1, [pc, #340]	; (8ec <printf_dec+0x268>)
 798:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 79c:	005b      	lsls	r3, r3, #1
 79e:	441a      	add	r2, r3
        } else if (val >=
 7a0:	687b      	ldr	r3, [r7, #4]
 7a2:	429a      	cmp	r2, r3
 7a4:	d810      	bhi.n	7c8 <printf_dec+0x144>
            tmp = 6;
 7a6:	2306      	movs	r3, #6
 7a8:	613b      	str	r3, [r7, #16]
            tmp_w = (hex_weight_value_table[i - 1] << 2) + (hex_weight_value_table[i - 1] << 1);
 7aa:	697b      	ldr	r3, [r7, #20]
 7ac:	3b01      	subs	r3, #1
 7ae:	4a4f      	ldr	r2, [pc, #316]	; (8ec <printf_dec+0x268>)
 7b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 7b4:	009a      	lsls	r2, r3, #2
 7b6:	697b      	ldr	r3, [r7, #20]
 7b8:	3b01      	subs	r3, #1
 7ba:	494c      	ldr	r1, [pc, #304]	; (8ec <printf_dec+0x268>)
 7bc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 7c0:	005b      	lsls	r3, r3, #1
 7c2:	4413      	add	r3, r2
 7c4:	60fb      	str	r3, [r7, #12]
 7c6:	e078      	b.n	8ba <printf_dec+0x236>
        } else if (val >= ((hex_weight_value_table[i - 1] << 2) + hex_weight_value_table[i - 1])) {
 7c8:	697b      	ldr	r3, [r7, #20]
 7ca:	3b01      	subs	r3, #1
 7cc:	4a47      	ldr	r2, [pc, #284]	; (8ec <printf_dec+0x268>)
 7ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 7d2:	009a      	lsls	r2, r3, #2
 7d4:	697b      	ldr	r3, [r7, #20]
 7d6:	3b01      	subs	r3, #1
 7d8:	4944      	ldr	r1, [pc, #272]	; (8ec <printf_dec+0x268>)
 7da:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 7de:	441a      	add	r2, r3
 7e0:	687b      	ldr	r3, [r7, #4]
 7e2:	429a      	cmp	r2, r3
 7e4:	d80f      	bhi.n	806 <printf_dec+0x182>
            tmp = 5;
 7e6:	2305      	movs	r3, #5
 7e8:	613b      	str	r3, [r7, #16]
            tmp_w = (hex_weight_value_table[i - 1] << 2) + hex_weight_value_table[i - 1];
 7ea:	697b      	ldr	r3, [r7, #20]
 7ec:	3b01      	subs	r3, #1
 7ee:	4a3f      	ldr	r2, [pc, #252]	; (8ec <printf_dec+0x268>)
 7f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 7f4:	009a      	lsls	r2, r3, #2
 7f6:	697b      	ldr	r3, [r7, #20]
 7f8:	3b01      	subs	r3, #1
 7fa:	493c      	ldr	r1, [pc, #240]	; (8ec <printf_dec+0x268>)
 7fc:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800:	4413      	add	r3, r2
 802:	60fb      	str	r3, [r7, #12]
 804:	e059      	b.n	8ba <printf_dec+0x236>
        } else if (val >= (hex_weight_value_table[i - 1] << 2)) {
 806:	697b      	ldr	r3, [r7, #20]
 808:	3b01      	subs	r3, #1
 80a:	4a38      	ldr	r2, [pc, #224]	; (8ec <printf_dec+0x268>)
 80c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 810:	009a      	lsls	r2, r3, #2
 812:	687b      	ldr	r3, [r7, #4]
 814:	429a      	cmp	r2, r3
 816:	d809      	bhi.n	82c <printf_dec+0x1a8>
            tmp = 4;
 818:	2304      	movs	r3, #4
 81a:	613b      	str	r3, [r7, #16]
            tmp_w = hex_weight_value_table[i - 1] << 2;
 81c:	697b      	ldr	r3, [r7, #20]
 81e:	3b01      	subs	r3, #1
 820:	4a32      	ldr	r2, [pc, #200]	; (8ec <printf_dec+0x268>)
 822:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 826:	009b      	lsls	r3, r3, #2
 828:	60fb      	str	r3, [r7, #12]
 82a:	e046      	b.n	8ba <printf_dec+0x236>
        } else if (val >= ((hex_weight_value_table[i - 1] << 1) + hex_weight_value_table[i - 1])) {
 82c:	697b      	ldr	r3, [r7, #20]
 82e:	3b01      	subs	r3, #1
 830:	4a2e      	ldr	r2, [pc, #184]	; (8ec <printf_dec+0x268>)
 832:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 836:	005a      	lsls	r2, r3, #1
 838:	697b      	ldr	r3, [r7, #20]
 83a:	3b01      	subs	r3, #1
 83c:	492b      	ldr	r1, [pc, #172]	; (8ec <printf_dec+0x268>)
 83e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 842:	441a      	add	r2, r3
 844:	687b      	ldr	r3, [r7, #4]
 846:	429a      	cmp	r2, r3
 848:	d80f      	bhi.n	86a <printf_dec+0x1e6>
            tmp = 3;
 84a:	2303      	movs	r3, #3
 84c:	613b      	str	r3, [r7, #16]
            tmp_w = (hex_weight_value_table[i - 1] << 1) + hex_weight_value_table[i - 1];
 84e:	697b      	ldr	r3, [r7, #20]
 850:	3b01      	subs	r3, #1
 852:	4a26      	ldr	r2, [pc, #152]	; (8ec <printf_dec+0x268>)
 854:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 858:	005a      	lsls	r2, r3, #1
 85a:	697b      	ldr	r3, [r7, #20]
 85c:	3b01      	subs	r3, #1
 85e:	4923      	ldr	r1, [pc, #140]	; (8ec <printf_dec+0x268>)
 860:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 864:	4413      	add	r3, r2
 866:	60fb      	str	r3, [r7, #12]
 868:	e027      	b.n	8ba <printf_dec+0x236>
        } else if (val >= (hex_weight_value_table[i - 1] << 1)) {
 86a:	697b      	ldr	r3, [r7, #20]
 86c:	3b01      	subs	r3, #1
 86e:	4a1f      	ldr	r2, [pc, #124]	; (8ec <printf_dec+0x268>)
 870:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 874:	005a      	lsls	r2, r3, #1
 876:	687b      	ldr	r3, [r7, #4]
 878:	429a      	cmp	r2, r3
 87a:	d809      	bhi.n	890 <printf_dec+0x20c>
            tmp = 2;
 87c:	2302      	movs	r3, #2
 87e:	613b      	str	r3, [r7, #16]
            tmp_w = hex_weight_value_table[i - 1] << 1;
 880:	697b      	ldr	r3, [r7, #20]
 882:	3b01      	subs	r3, #1
 884:	4a19      	ldr	r2, [pc, #100]	; (8ec <printf_dec+0x268>)
 886:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 88a:	005b      	lsls	r3, r3, #1
 88c:	60fb      	str	r3, [r7, #12]
 88e:	e014      	b.n	8ba <printf_dec+0x236>
        } else if (val >= (hex_weight_value_table[i - 1])) {
 890:	697b      	ldr	r3, [r7, #20]
 892:	3b01      	subs	r3, #1
 894:	4a15      	ldr	r2, [pc, #84]	; (8ec <printf_dec+0x268>)
 896:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 89a:	687b      	ldr	r3, [r7, #4]
 89c:	429a      	cmp	r2, r3
 89e:	d808      	bhi.n	8b2 <printf_dec+0x22e>
            tmp = 1;
 8a0:	2301      	movs	r3, #1
 8a2:	613b      	str	r3, [r7, #16]
            tmp_w = hex_weight_value_table[i - 1];
 8a4:	697b      	ldr	r3, [r7, #20]
 8a6:	3b01      	subs	r3, #1
 8a8:	4a10      	ldr	r2, [pc, #64]	; (8ec <printf_dec+0x268>)
 8aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8ae:	60fb      	str	r3, [r7, #12]
 8b0:	e003      	b.n	8ba <printf_dec+0x236>
        } else {
            tmp = 0;
 8b2:	2300      	movs	r3, #0
 8b4:	613b      	str	r3, [r7, #16]
            tmp_w = 0;
 8b6:	2300      	movs	r3, #0
 8b8:	60fb      	str	r3, [r7, #12]
        }

        asc = hex_asc_table[tmp];
 8ba:	4a0d      	ldr	r2, [pc, #52]	; (8f0 <printf_dec+0x26c>)
 8bc:	693b      	ldr	r3, [r7, #16]
 8be:	4413      	add	r3, r2
 8c0:	781b      	ldrb	r3, [r3, #0]
 8c2:	72fb      	strb	r3, [r7, #11]
        printf_char(asc);
 8c4:	7afb      	ldrb	r3, [r7, #11]
 8c6:	4618      	mov	r0, r3
 8c8:	f7ff fe32 	bl	530 <printf_char>
        i--;
 8cc:	697b      	ldr	r3, [r7, #20]
 8ce:	3b01      	subs	r3, #1
 8d0:	617b      	str	r3, [r7, #20]

        val -= tmp_w;
 8d2:	687a      	ldr	r2, [r7, #4]
 8d4:	68fb      	ldr	r3, [r7, #12]
 8d6:	1ad3      	subs	r3, r2, r3
 8d8:	607b      	str	r3, [r7, #4]
    while (i > 0) {
 8da:	697b      	ldr	r3, [r7, #20]
 8dc:	2b00      	cmp	r3, #0
 8de:	f47f aef3 	bne.w	6c8 <printf_dec+0x44>
    }

    return 0;
 8e2:	2300      	movs	r3, #0
}
 8e4:	4618      	mov	r0, r3
 8e6:	3718      	adds	r7, #24
 8e8:	46bd      	mov	sp, r7
 8ea:	bd80      	pop	{r7, pc}
 8ec:	00000df0 	.word	0x00000df0
 8f0:	00000dd0 	.word	0x00000dd0

000008f4 <easy_printf>:
#endif

void easy_printf(const char *fmt, ...)
{
 8f4:	b40f      	push	{r0, r1, r2, r3}
 8f6:	b580      	push	{r7, lr}
 8f8:	b084      	sub	sp, #16
 8fa:	af00      	add	r7, sp, #0
    char c;
    uint32_t width = 0;
 8fc:	2300      	movs	r3, #0
 8fe:	60fb      	str	r3, [r7, #12]
    va_list argptr;

    va_start(argptr, fmt);
 900:	f107 031c 	add.w	r3, r7, #28
 904:	607b      	str	r3, [r7, #4]
    do {
        c = *fmt;
 906:	69bb      	ldr	r3, [r7, #24]
 908:	781b      	ldrb	r3, [r3, #0]
 90a:	72fb      	strb	r3, [r7, #11]
        if (c != '%') {
 90c:	7afb      	ldrb	r3, [r7, #11]
 90e:	2b25      	cmp	r3, #37	; 0x25
 910:	d004      	beq.n	91c <easy_printf+0x28>
            printf_char(c);
 912:	7afb      	ldrb	r3, [r7, #11]
 914:	4618      	mov	r0, r3
 916:	f7ff fe0b 	bl	530 <printf_char>
 91a:	e09d      	b.n	a58 <easy_printf+0x164>
        } else {
            while (1) {
                c = *++fmt;
 91c:	69bb      	ldr	r3, [r7, #24]
 91e:	3301      	adds	r3, #1
 920:	61bb      	str	r3, [r7, #24]
 922:	69bb      	ldr	r3, [r7, #24]
 924:	781b      	ldrb	r3, [r3, #0]
 926:	72fb      	strb	r3, [r7, #11]
                if ((c == 'd') || (c == 'x') || (c == 'X') || (c == 's') || (c == 'c')) {
 928:	7afb      	ldrb	r3, [r7, #11]
 92a:	2b64      	cmp	r3, #100	; 0x64
 92c:	d00b      	beq.n	946 <easy_printf+0x52>
 92e:	7afb      	ldrb	r3, [r7, #11]
 930:	2b78      	cmp	r3, #120	; 0x78
 932:	d008      	beq.n	946 <easy_printf+0x52>
 934:	7afb      	ldrb	r3, [r7, #11]
 936:	2b58      	cmp	r3, #88	; 0x58
 938:	d005      	beq.n	946 <easy_printf+0x52>
 93a:	7afb      	ldrb	r3, [r7, #11]
 93c:	2b73      	cmp	r3, #115	; 0x73
 93e:	d002      	beq.n	946 <easy_printf+0x52>
 940:	7afb      	ldrb	r3, [r7, #11]
 942:	2b63      	cmp	r3, #99	; 0x63
 944:	d1ea      	bne.n	91c <easy_printf+0x28>
                    if ((c == 'x') || (c == 'X')) {
 946:	7afb      	ldrb	r3, [r7, #11]
 948:	2b78      	cmp	r3, #120	; 0x78
 94a:	d002      	beq.n	952 <easy_printf+0x5e>
 94c:	7afb      	ldrb	r3, [r7, #11]
 94e:	2b58      	cmp	r3, #88	; 0x58
 950:	d10c      	bne.n	96c <easy_printf+0x78>
                        if (*(fmt - 1) == '%')
 952:	69bb      	ldr	r3, [r7, #24]
 954:	3b01      	subs	r3, #1
 956:	781b      	ldrb	r3, [r3, #0]
 958:	2b25      	cmp	r3, #37	; 0x25
 95a:	d102      	bne.n	962 <easy_printf+0x6e>
                            width = 8;
 95c:	2308      	movs	r3, #8
 95e:	60fb      	str	r3, [r7, #12]
                        else
                            width = *(fmt - 1) - '0';
                    }
                    break;
 960:	e004      	b.n	96c <easy_printf+0x78>
                            width = *(fmt - 1) - '0';
 962:	69bb      	ldr	r3, [r7, #24]
 964:	3b01      	subs	r3, #1
 966:	781b      	ldrb	r3, [r3, #0]
 968:	3b30      	subs	r3, #48	; 0x30
 96a:	60fb      	str	r3, [r7, #12]
                    break;
 96c:	bf00      	nop
                }
            }

            switch (c) {
 96e:	7afb      	ldrb	r3, [r7, #11]
 970:	3b58      	subs	r3, #88	; 0x58
 972:	2b20      	cmp	r3, #32
 974:	d86f      	bhi.n	a56 <easy_printf+0x162>
 976:	a201      	add	r2, pc, #4	; (adr r2, 97c <easy_printf+0x88>)
 978:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 97c:	00000a23 	.word	0x00000a23
 980:	00000a57 	.word	0x00000a57
 984:	00000a57 	.word	0x00000a57
 988:	00000a57 	.word	0x00000a57
 98c:	00000a57 	.word	0x00000a57
 990:	00000a57 	.word	0x00000a57
 994:	00000a57 	.word	0x00000a57
 998:	00000a57 	.word	0x00000a57
 99c:	00000a57 	.word	0x00000a57
 9a0:	00000a57 	.word	0x00000a57
 9a4:	00000a57 	.word	0x00000a57
 9a8:	00000a45 	.word	0x00000a45
 9ac:	00000a01 	.word	0x00000a01
 9b0:	00000a57 	.word	0x00000a57
 9b4:	00000a57 	.word	0x00000a57
 9b8:	00000a57 	.word	0x00000a57
 9bc:	00000a57 	.word	0x00000a57
 9c0:	00000a57 	.word	0x00000a57
 9c4:	00000a57 	.word	0x00000a57
 9c8:	00000a57 	.word	0x00000a57
 9cc:	00000a57 	.word	0x00000a57
 9d0:	00000a57 	.word	0x00000a57
 9d4:	00000a57 	.word	0x00000a57
 9d8:	00000a57 	.word	0x00000a57
 9dc:	00000a57 	.word	0x00000a57
 9e0:	00000a57 	.word	0x00000a57
 9e4:	00000a57 	.word	0x00000a57
 9e8:	00000a35 	.word	0x00000a35
 9ec:	00000a57 	.word	0x00000a57
 9f0:	00000a57 	.word	0x00000a57
 9f4:	00000a57 	.word	0x00000a57
 9f8:	00000a57 	.word	0x00000a57
 9fc:	00000a11 	.word	0x00000a11
            case 'd':
                printf_dec(va_arg(argptr, int));
 a00:	687b      	ldr	r3, [r7, #4]
 a02:	1d1a      	adds	r2, r3, #4
 a04:	607a      	str	r2, [r7, #4]
 a06:	681b      	ldr	r3, [r3, #0]
 a08:	4618      	mov	r0, r3
 a0a:	f7ff fe3b 	bl	684 <printf_dec>
                break;
 a0e:	e023      	b.n	a58 <easy_printf+0x164>
            case 'x':
                printf_hex((va_arg(argptr, int)), width);
 a10:	687b      	ldr	r3, [r7, #4]
 a12:	1d1a      	adds	r2, r3, #4
 a14:	607a      	str	r2, [r7, #4]
 a16:	681b      	ldr	r3, [r3, #0]
 a18:	68f9      	ldr	r1, [r7, #12]
 a1a:	4618      	mov	r0, r3
 a1c:	f7ff fdbe 	bl	59c <printf_hex>
                break;
 a20:	e01a      	b.n	a58 <easy_printf+0x164>
            case 'X':
                printf_hex_upper((va_arg(argptr, int)), width);
 a22:	687b      	ldr	r3, [r7, #4]
 a24:	1d1a      	adds	r2, r3, #4
 a26:	607a      	str	r2, [r7, #4]
 a28:	681b      	ldr	r3, [r3, #0]
 a2a:	68f9      	ldr	r1, [r7, #12]
 a2c:	4618      	mov	r0, r3
 a2e:	f7ff fdef 	bl	610 <printf_hex_upper>
                break;
 a32:	e011      	b.n	a58 <easy_printf+0x164>
            case 's':
                printf_str(va_arg(argptr, char *));
 a34:	687b      	ldr	r3, [r7, #4]
 a36:	1d1a      	adds	r2, r3, #4
 a38:	607a      	str	r2, [r7, #4]
 a3a:	681b      	ldr	r3, [r3, #0]
 a3c:	4618      	mov	r0, r3
 a3e:	f7ff fd94 	bl	56a <printf_str>
                break;
 a42:	e009      	b.n	a58 <easy_printf+0x164>
            case 'c':
                printf_char(va_arg(argptr, int));
 a44:	687b      	ldr	r3, [r7, #4]
 a46:	1d1a      	adds	r2, r3, #4
 a48:	607a      	str	r2, [r7, #4]
 a4a:	681b      	ldr	r3, [r3, #0]
 a4c:	b2db      	uxtb	r3, r3
 a4e:	4618      	mov	r0, r3
 a50:	f7ff fd6e 	bl	530 <printf_char>
                break;
 a54:	e000      	b.n	a58 <easy_printf+0x164>
            default:
                break;
 a56:	bf00      	nop
            }
        }
        ++fmt;
 a58:	69bb      	ldr	r3, [r7, #24]
 a5a:	3301      	adds	r3, #1
 a5c:	61bb      	str	r3, [r7, #24]
    }
    while (*fmt != '\0');
 a5e:	69bb      	ldr	r3, [r7, #24]
 a60:	781b      	ldrb	r3, [r3, #0]
 a62:	2b00      	cmp	r3, #0
 a64:	f47f af4f 	bne.w	906 <easy_printf+0x12>

    va_end(argptr);
}
 a68:	bf00      	nop
 a6a:	3710      	adds	r7, #16
 a6c:	46bd      	mov	sp, r7
 a6e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 a72:	b004      	add	sp, #16
 a74:	4770      	bx	lr

00000a76 <easy_memset>:

int easy_memset(void *mem, uint8_t val, uint32_t sz)
{
 a76:	b480      	push	{r7}
 a78:	b087      	sub	sp, #28
 a7a:	af00      	add	r7, sp, #0
 a7c:	60f8      	str	r0, [r7, #12]
 a7e:	460b      	mov	r3, r1
 a80:	607a      	str	r2, [r7, #4]
 a82:	72fb      	strb	r3, [r7, #11]
    uint8_t *p = (uint8_t *)mem;
 a84:	68fb      	ldr	r3, [r7, #12]
 a86:	617b      	str	r3, [r7, #20]
    int i = 0;
 a88:	2300      	movs	r3, #0
 a8a:	613b      	str	r3, [r7, #16]

    for (i = 0; i < sz; i++, *p++ = val) ;
 a8c:	2300      	movs	r3, #0
 a8e:	613b      	str	r3, [r7, #16]
 a90:	e007      	b.n	aa2 <easy_memset+0x2c>
 a92:	693b      	ldr	r3, [r7, #16]
 a94:	3301      	adds	r3, #1
 a96:	613b      	str	r3, [r7, #16]
 a98:	697b      	ldr	r3, [r7, #20]
 a9a:	1c5a      	adds	r2, r3, #1
 a9c:	617a      	str	r2, [r7, #20]
 a9e:	7afa      	ldrb	r2, [r7, #11]
 aa0:	701a      	strb	r2, [r3, #0]
 aa2:	693a      	ldr	r2, [r7, #16]
 aa4:	687b      	ldr	r3, [r7, #4]
 aa6:	429a      	cmp	r2, r3
 aa8:	d3f3      	bcc.n	a92 <easy_memset+0x1c>

    return 0;
 aaa:	2300      	movs	r3, #0
}
 aac:	4618      	mov	r0, r3
 aae:	371c      	adds	r7, #28
 ab0:	46bd      	mov	sp, r7
 ab2:	bc80      	pop	{r7}
 ab4:	4770      	bx	lr

00000ab6 <easy_memcpy>:

int easy_memcpy(void *dst, const void *src, uint32_t sz)
{
 ab6:	b480      	push	{r7}
 ab8:	b089      	sub	sp, #36	; 0x24
 aba:	af00      	add	r7, sp, #0
 abc:	60f8      	str	r0, [r7, #12]
 abe:	60b9      	str	r1, [r7, #8]
 ac0:	607a      	str	r2, [r7, #4]
    uint8_t *p_dst = (uint8_t *)dst;
 ac2:	68fb      	ldr	r3, [r7, #12]
 ac4:	61fb      	str	r3, [r7, #28]
    uint8_t *p_src = (uint8_t *)src;
 ac6:	68bb      	ldr	r3, [r7, #8]
 ac8:	61bb      	str	r3, [r7, #24]
    int i = 0;
 aca:	2300      	movs	r3, #0
 acc:	617b      	str	r3, [r7, #20]

    for (i = 0; i < sz; i++, *p_dst++ = *p_src++) ;
 ace:	2300      	movs	r3, #0
 ad0:	617b      	str	r3, [r7, #20]
 ad2:	e00a      	b.n	aea <easy_memcpy+0x34>
 ad4:	697b      	ldr	r3, [r7, #20]
 ad6:	3301      	adds	r3, #1
 ad8:	617b      	str	r3, [r7, #20]
 ada:	69fb      	ldr	r3, [r7, #28]
 adc:	1c5a      	adds	r2, r3, #1
 ade:	61fa      	str	r2, [r7, #28]
 ae0:	69ba      	ldr	r2, [r7, #24]
 ae2:	1c51      	adds	r1, r2, #1
 ae4:	61b9      	str	r1, [r7, #24]
 ae6:	7812      	ldrb	r2, [r2, #0]
 ae8:	701a      	strb	r2, [r3, #0]
 aea:	697a      	ldr	r2, [r7, #20]
 aec:	687b      	ldr	r3, [r7, #4]
 aee:	429a      	cmp	r2, r3
 af0:	d3f0      	bcc.n	ad4 <easy_memcpy+0x1e>

    return 0;
 af2:	2300      	movs	r3, #0
}
 af4:	4618      	mov	r0, r3
 af6:	3724      	adds	r7, #36	; 0x24
 af8:	46bd      	mov	sp, r7
 afa:	bc80      	pop	{r7}
 afc:	4770      	bx	lr

00000afe <easy_memcmp>:

int easy_memcmp(void *mem1, void *mem2, uint32_t sz)
{
 afe:	b480      	push	{r7}
 b00:	b089      	sub	sp, #36	; 0x24
 b02:	af00      	add	r7, sp, #0
 b04:	60f8      	str	r0, [r7, #12]
 b06:	60b9      	str	r1, [r7, #8]
 b08:	607a      	str	r2, [r7, #4]
    uint8_t *p_mem1 = (uint8_t *)mem1;
 b0a:	68fb      	ldr	r3, [r7, #12]
 b0c:	61fb      	str	r3, [r7, #28]
    uint8_t *p_mem2 = (uint8_t *)mem2;
 b0e:	68bb      	ldr	r3, [r7, #8]
 b10:	61bb      	str	r3, [r7, #24]
    int i = 0;
 b12:	2300      	movs	r3, #0
 b14:	617b      	str	r3, [r7, #20]

    for (i = 0; i < sz; i++, p_mem1++, p_mem2++) {
 b16:	2300      	movs	r3, #0
 b18:	617b      	str	r3, [r7, #20]
 b1a:	e00e      	b.n	b3a <easy_memcmp+0x3c>
        if (*p_mem1 != *p_mem2) {
 b1c:	69fb      	ldr	r3, [r7, #28]
 b1e:	781a      	ldrb	r2, [r3, #0]
 b20:	69bb      	ldr	r3, [r7, #24]
 b22:	781b      	ldrb	r3, [r3, #0]
 b24:	429a      	cmp	r2, r3
 b26:	d10d      	bne.n	b44 <easy_memcmp+0x46>
    for (i = 0; i < sz; i++, p_mem1++, p_mem2++) {
 b28:	697b      	ldr	r3, [r7, #20]
 b2a:	3301      	adds	r3, #1
 b2c:	617b      	str	r3, [r7, #20]
 b2e:	69fb      	ldr	r3, [r7, #28]
 b30:	3301      	adds	r3, #1
 b32:	61fb      	str	r3, [r7, #28]
 b34:	69bb      	ldr	r3, [r7, #24]
 b36:	3301      	adds	r3, #1
 b38:	61bb      	str	r3, [r7, #24]
 b3a:	697a      	ldr	r2, [r7, #20]
 b3c:	687b      	ldr	r3, [r7, #4]
 b3e:	429a      	cmp	r2, r3
 b40:	d3ec      	bcc.n	b1c <easy_memcmp+0x1e>
 b42:	e000      	b.n	b46 <easy_memcmp+0x48>
            break;
 b44:	bf00      	nop
        }
    }

    if (i < sz) {
 b46:	697a      	ldr	r2, [r7, #20]
 b48:	687b      	ldr	r3, [r7, #4]
 b4a:	429a      	cmp	r2, r3
 b4c:	d201      	bcs.n	b52 <easy_memcmp+0x54>
        return 1;
 b4e:	2301      	movs	r3, #1
 b50:	e000      	b.n	b54 <easy_memcmp+0x56>
    } else {
        return 0;
 b52:	2300      	movs	r3, #0
    }
}
 b54:	4618      	mov	r0, r3
 b56:	3724      	adds	r7, #36	; 0x24
 b58:	46bd      	mov	sp, r7
 b5a:	bc80      	pop	{r7}
 b5c:	4770      	bx	lr

00000b5e <easy_strcmp>:

int easy_strcmp(char *str1, char *str2)
{
 b5e:	b480      	push	{r7}
 b60:	b085      	sub	sp, #20
 b62:	af00      	add	r7, sp, #0
 b64:	6078      	str	r0, [r7, #4]
 b66:	6039      	str	r1, [r7, #0]
    char *p1 = str1, *p2 = str2;
 b68:	687b      	ldr	r3, [r7, #4]
 b6a:	60fb      	str	r3, [r7, #12]
 b6c:	683b      	ldr	r3, [r7, #0]
 b6e:	60bb      	str	r3, [r7, #8]

    while ((*p1 != 0) && (*p2 != 0) && (*p1 == *p2)) {
 b70:	e005      	b.n	b7e <easy_strcmp+0x20>
        p1++;
 b72:	68fb      	ldr	r3, [r7, #12]
 b74:	3301      	adds	r3, #1
 b76:	60fb      	str	r3, [r7, #12]
        p2++;
 b78:	68bb      	ldr	r3, [r7, #8]
 b7a:	3301      	adds	r3, #1
 b7c:	60bb      	str	r3, [r7, #8]
    while ((*p1 != 0) && (*p2 != 0) && (*p1 == *p2)) {
 b7e:	68fb      	ldr	r3, [r7, #12]
 b80:	781b      	ldrb	r3, [r3, #0]
 b82:	2b00      	cmp	r3, #0
 b84:	d009      	beq.n	b9a <easy_strcmp+0x3c>
 b86:	68bb      	ldr	r3, [r7, #8]
 b88:	781b      	ldrb	r3, [r3, #0]
 b8a:	2b00      	cmp	r3, #0
 b8c:	d005      	beq.n	b9a <easy_strcmp+0x3c>
 b8e:	68fb      	ldr	r3, [r7, #12]
 b90:	781a      	ldrb	r2, [r3, #0]
 b92:	68bb      	ldr	r3, [r7, #8]
 b94:	781b      	ldrb	r3, [r3, #0]
 b96:	429a      	cmp	r2, r3
 b98:	d0eb      	beq.n	b72 <easy_strcmp+0x14>
    }

    return *p1 - *p2;
 b9a:	68fb      	ldr	r3, [r7, #12]
 b9c:	781b      	ldrb	r3, [r3, #0]
 b9e:	461a      	mov	r2, r3
 ba0:	68bb      	ldr	r3, [r7, #8]
 ba2:	781b      	ldrb	r3, [r3, #0]
 ba4:	1ad3      	subs	r3, r2, r3
}
 ba6:	4618      	mov	r0, r3
 ba8:	3714      	adds	r7, #20
 baa:	46bd      	mov	sp, r7
 bac:	bc80      	pop	{r7}
 bae:	4770      	bx	lr

00000bb0 <easy_strncmp>:

int easy_strncmp(char *str1, char *str2, uint32_t sz)
{
 bb0:	b480      	push	{r7}
 bb2:	b089      	sub	sp, #36	; 0x24
 bb4:	af00      	add	r7, sp, #0
 bb6:	60f8      	str	r0, [r7, #12]
 bb8:	60b9      	str	r1, [r7, #8]
 bba:	607a      	str	r2, [r7, #4]
    char *p1 = str1, *p2 = str2;
 bbc:	68fb      	ldr	r3, [r7, #12]
 bbe:	61fb      	str	r3, [r7, #28]
 bc0:	68bb      	ldr	r3, [r7, #8]
 bc2:	61bb      	str	r3, [r7, #24]
    int i = 0;
 bc4:	2300      	movs	r3, #0
 bc6:	617b      	str	r3, [r7, #20]

    for (; i < sz; i++, p1++, p2++) {
 bc8:	e019      	b.n	bfe <easy_strncmp+0x4e>
        if (*p1 > *p2) {
 bca:	69fb      	ldr	r3, [r7, #28]
 bcc:	781a      	ldrb	r2, [r3, #0]
 bce:	69bb      	ldr	r3, [r7, #24]
 bd0:	781b      	ldrb	r3, [r3, #0]
 bd2:	429a      	cmp	r2, r3
 bd4:	d901      	bls.n	bda <easy_strncmp+0x2a>
            return 1;
 bd6:	2301      	movs	r3, #1
 bd8:	e016      	b.n	c08 <easy_strncmp+0x58>
        }
        if (*p1 < *p2) {
 bda:	69fb      	ldr	r3, [r7, #28]
 bdc:	781a      	ldrb	r2, [r3, #0]
 bde:	69bb      	ldr	r3, [r7, #24]
 be0:	781b      	ldrb	r3, [r3, #0]
 be2:	429a      	cmp	r2, r3
 be4:	d202      	bcs.n	bec <easy_strncmp+0x3c>
            return -1;
 be6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 bea:	e00d      	b.n	c08 <easy_strncmp+0x58>
    for (; i < sz; i++, p1++, p2++) {
 bec:	697b      	ldr	r3, [r7, #20]
 bee:	3301      	adds	r3, #1
 bf0:	617b      	str	r3, [r7, #20]
 bf2:	69fb      	ldr	r3, [r7, #28]
 bf4:	3301      	adds	r3, #1
 bf6:	61fb      	str	r3, [r7, #28]
 bf8:	69bb      	ldr	r3, [r7, #24]
 bfa:	3301      	adds	r3, #1
 bfc:	61bb      	str	r3, [r7, #24]
 bfe:	697a      	ldr	r2, [r7, #20]
 c00:	687b      	ldr	r3, [r7, #4]
 c02:	429a      	cmp	r2, r3
 c04:	d3e1      	bcc.n	bca <easy_strncmp+0x1a>
        }
    }

    return 0;
 c06:	2300      	movs	r3, #0
}
 c08:	4618      	mov	r0, r3
 c0a:	3724      	adds	r7, #36	; 0x24
 c0c:	46bd      	mov	sp, r7
 c0e:	bc80      	pop	{r7}
 c10:	4770      	bx	lr

00000c12 <easy_strtoul>:

int easy_strtoul(char *str, uint32_t *val)
{
 c12:	b580      	push	{r7, lr}
 c14:	b086      	sub	sp, #24
 c16:	af00      	add	r7, sp, #0
 c18:	6078      	str	r0, [r7, #4]
 c1a:	6039      	str	r1, [r7, #0]
    char *p = str;
 c1c:	687b      	ldr	r3, [r7, #4]
 c1e:	617b      	str	r3, [r7, #20]
    uint32_t multiplier = 10;
 c20:	230a      	movs	r3, #10
 c22:	613b      	str	r3, [r7, #16]
    uint32_t result = 0, num = 0;
 c24:	2300      	movs	r3, #0
 c26:	60fb      	str	r3, [r7, #12]
 c28:	2300      	movs	r3, #0
 c2a:	60bb      	str	r3, [r7, #8]

    if (*p == '0' && (*(p + 1) == 'x' || *(p + 1) == 'X')) {
 c2c:	697b      	ldr	r3, [r7, #20]
 c2e:	781b      	ldrb	r3, [r3, #0]
 c30:	2b30      	cmp	r3, #48	; 0x30
 c32:	d155      	bne.n	ce0 <easy_strtoul+0xce>
 c34:	697b      	ldr	r3, [r7, #20]
 c36:	3301      	adds	r3, #1
 c38:	781b      	ldrb	r3, [r3, #0]
 c3a:	2b78      	cmp	r3, #120	; 0x78
 c3c:	d004      	beq.n	c48 <easy_strtoul+0x36>
 c3e:	697b      	ldr	r3, [r7, #20]
 c40:	3301      	adds	r3, #1
 c42:	781b      	ldrb	r3, [r3, #0]
 c44:	2b58      	cmp	r3, #88	; 0x58
 c46:	d14b      	bne.n	ce0 <easy_strtoul+0xce>
        p += 2;
 c48:	697b      	ldr	r3, [r7, #20]
 c4a:	3302      	adds	r3, #2
 c4c:	617b      	str	r3, [r7, #20]
        multiplier = 0x10;
 c4e:	2310      	movs	r3, #16
 c50:	613b      	str	r3, [r7, #16]
    }

    while (0 != *p) {
 c52:	e045      	b.n	ce0 <easy_strtoul+0xce>
        if (multiplier == 0x10) {
 c54:	693b      	ldr	r3, [r7, #16]
 c56:	2b10      	cmp	r3, #16
 c58:	d129      	bne.n	cae <easy_strtoul+0x9c>
            if (!is_hex_asc(*p)) {
 c5a:	697b      	ldr	r3, [r7, #20]
 c5c:	781b      	ldrb	r3, [r3, #0]
 c5e:	4618      	mov	r0, r3
 c60:	f7ff fc47 	bl	4f2 <is_hex_asc>
 c64:	4603      	mov	r3, r0
 c66:	2b00      	cmp	r3, #0
 c68:	d102      	bne.n	c70 <easy_strtoul+0x5e>
                return -1;
 c6a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 c6e:	e03f      	b.n	cf0 <easy_strtoul+0xde>
            }
            if (*p >= '0' && *p <= '9') {
 c70:	697b      	ldr	r3, [r7, #20]
 c72:	781b      	ldrb	r3, [r3, #0]
 c74:	2b2f      	cmp	r3, #47	; 0x2f
 c76:	d908      	bls.n	c8a <easy_strtoul+0x78>
 c78:	697b      	ldr	r3, [r7, #20]
 c7a:	781b      	ldrb	r3, [r3, #0]
 c7c:	2b39      	cmp	r3, #57	; 0x39
 c7e:	d804      	bhi.n	c8a <easy_strtoul+0x78>
                num = *p - '0';
 c80:	697b      	ldr	r3, [r7, #20]
 c82:	781b      	ldrb	r3, [r3, #0]
 c84:	3b30      	subs	r3, #48	; 0x30
 c86:	60bb      	str	r3, [r7, #8]
 c88:	e020      	b.n	ccc <easy_strtoul+0xba>
            } else if (*p >= 'a' && *p <= 'f') {
 c8a:	697b      	ldr	r3, [r7, #20]
 c8c:	781b      	ldrb	r3, [r3, #0]
 c8e:	2b60      	cmp	r3, #96	; 0x60
 c90:	d908      	bls.n	ca4 <easy_strtoul+0x92>
 c92:	697b      	ldr	r3, [r7, #20]
 c94:	781b      	ldrb	r3, [r3, #0]
 c96:	2b66      	cmp	r3, #102	; 0x66
 c98:	d804      	bhi.n	ca4 <easy_strtoul+0x92>
                num = *p - 'a' + 10;
 c9a:	697b      	ldr	r3, [r7, #20]
 c9c:	781b      	ldrb	r3, [r3, #0]
 c9e:	3b57      	subs	r3, #87	; 0x57
 ca0:	60bb      	str	r3, [r7, #8]
 ca2:	e013      	b.n	ccc <easy_strtoul+0xba>
            } else {
                num = *p - 'A' + 10;
 ca4:	697b      	ldr	r3, [r7, #20]
 ca6:	781b      	ldrb	r3, [r3, #0]
 ca8:	3b37      	subs	r3, #55	; 0x37
 caa:	60bb      	str	r3, [r7, #8]
 cac:	e00e      	b.n	ccc <easy_strtoul+0xba>
            }
        } else {
            if (!is_dec_asc(*p)) {
 cae:	697b      	ldr	r3, [r7, #20]
 cb0:	781b      	ldrb	r3, [r3, #0]
 cb2:	4618      	mov	r0, r3
 cb4:	f7ff fbe4 	bl	480 <is_dec_asc>
 cb8:	4603      	mov	r3, r0
 cba:	2b00      	cmp	r3, #0
 cbc:	d102      	bne.n	cc4 <easy_strtoul+0xb2>
                return -2;
 cbe:	f06f 0301 	mvn.w	r3, #1
 cc2:	e015      	b.n	cf0 <easy_strtoul+0xde>
            }

            num = *p - '0';
 cc4:	697b      	ldr	r3, [r7, #20]
 cc6:	781b      	ldrb	r3, [r3, #0]
 cc8:	3b30      	subs	r3, #48	; 0x30
 cca:	60bb      	str	r3, [r7, #8]
        }

        result = result * multiplier + num;
 ccc:	68fb      	ldr	r3, [r7, #12]
 cce:	693a      	ldr	r2, [r7, #16]
 cd0:	fb02 f203 	mul.w	r2, r2, r3
 cd4:	68bb      	ldr	r3, [r7, #8]
 cd6:	4413      	add	r3, r2
 cd8:	60fb      	str	r3, [r7, #12]

        p++;
 cda:	697b      	ldr	r3, [r7, #20]
 cdc:	3301      	adds	r3, #1
 cde:	617b      	str	r3, [r7, #20]
    while (0 != *p) {
 ce0:	697b      	ldr	r3, [r7, #20]
 ce2:	781b      	ldrb	r3, [r3, #0]
 ce4:	2b00      	cmp	r3, #0
 ce6:	d1b5      	bne.n	c54 <easy_strtoul+0x42>
    }

    *val = result;
 ce8:	683b      	ldr	r3, [r7, #0]
 cea:	68fa      	ldr	r2, [r7, #12]
 cec:	601a      	str	r2, [r3, #0]

    return 0;
 cee:	2300      	movs	r3, #0
}
 cf0:	4618      	mov	r0, r3
 cf2:	3718      	adds	r7, #24
 cf4:	46bd      	mov	sp, r7
 cf6:	bd80      	pop	{r7, pc}

00000cf8 <easy_strtol>:

int easy_strtol(char *str, int *val)
{
 cf8:	b580      	push	{r7, lr}
 cfa:	b084      	sub	sp, #16
 cfc:	af00      	add	r7, sp, #0
 cfe:	6078      	str	r0, [r7, #4]
 d00:	6039      	str	r1, [r7, #0]
    char *p = str;
 d02:	687b      	ldr	r3, [r7, #4]
 d04:	60fb      	str	r3, [r7, #12]
    int ret;

    if (*p == '-') {
 d06:	68fb      	ldr	r3, [r7, #12]
 d08:	781b      	ldrb	r3, [r3, #0]
 d0a:	2b2d      	cmp	r3, #45	; 0x2d
 d0c:	d10e      	bne.n	d2c <easy_strtol+0x34>
        ret = easy_strtoul(++p, (uint32_t *)val);
 d0e:	68fb      	ldr	r3, [r7, #12]
 d10:	3301      	adds	r3, #1
 d12:	60fb      	str	r3, [r7, #12]
 d14:	6839      	ldr	r1, [r7, #0]
 d16:	68f8      	ldr	r0, [r7, #12]
 d18:	f7ff ff7b 	bl	c12 <easy_strtoul>
 d1c:	60b8      	str	r0, [r7, #8]
        *val = -(*val);
 d1e:	683b      	ldr	r3, [r7, #0]
 d20:	681b      	ldr	r3, [r3, #0]
 d22:	425a      	negs	r2, r3
 d24:	683b      	ldr	r3, [r7, #0]
 d26:	601a      	str	r2, [r3, #0]
        return ret;
 d28:	68bb      	ldr	r3, [r7, #8]
 d2a:	e004      	b.n	d36 <easy_strtol+0x3e>
    } else
        return easy_strtoul(p, (uint32_t *)val);
 d2c:	6839      	ldr	r1, [r7, #0]
 d2e:	68f8      	ldr	r0, [r7, #12]
 d30:	f7ff ff6f 	bl	c12 <easy_strtoul>
 d34:	4603      	mov	r3, r0

}
 d36:	4618      	mov	r0, r3
 d38:	3710      	adds	r7, #16
 d3a:	46bd      	mov	sp, r7
 d3c:	bd80      	pop	{r7, pc}

00000d3e <easy_strlen>:

uint32_t easy_strlen(char *str)
{
 d3e:	b480      	push	{r7}
 d40:	b085      	sub	sp, #20
 d42:	af00      	add	r7, sp, #0
 d44:	6078      	str	r0, [r7, #4]
    char *p = str;
 d46:	687b      	ldr	r3, [r7, #4]
 d48:	60fb      	str	r3, [r7, #12]

    while (*p++ != '\0') ;
 d4a:	bf00      	nop
 d4c:	68fb      	ldr	r3, [r7, #12]
 d4e:	1c5a      	adds	r2, r3, #1
 d50:	60fa      	str	r2, [r7, #12]
 d52:	781b      	ldrb	r3, [r3, #0]
 d54:	2b00      	cmp	r3, #0
 d56:	d1f9      	bne.n	d4c <easy_strlen+0xe>

    return (uint32_t)(p - str);
 d58:	68fa      	ldr	r2, [r7, #12]
 d5a:	687b      	ldr	r3, [r7, #4]
 d5c:	1ad3      	subs	r3, r2, r3
}
 d5e:	4618      	mov	r0, r3
 d60:	3714      	adds	r7, #20
 d62:	46bd      	mov	sp, r7
 d64:	bc80      	pop	{r7}
 d66:	4770      	bx	lr

00000d68 <easy_strcpy>:

int easy_strcpy(char *dst, char *src)
{
 d68:	b480      	push	{r7}
 d6a:	b085      	sub	sp, #20
 d6c:	af00      	add	r7, sp, #0
 d6e:	6078      	str	r0, [r7, #4]
 d70:	6039      	str	r1, [r7, #0]
    char *p_dst = dst, *p_src = src;
 d72:	687b      	ldr	r3, [r7, #4]
 d74:	60fb      	str	r3, [r7, #12]
 d76:	683b      	ldr	r3, [r7, #0]
 d78:	60bb      	str	r3, [r7, #8]

    while (*p_src != '\0') {
 d7a:	e009      	b.n	d90 <easy_strcpy+0x28>
        *p_dst = *p_src;
 d7c:	68bb      	ldr	r3, [r7, #8]
 d7e:	781a      	ldrb	r2, [r3, #0]
 d80:	68fb      	ldr	r3, [r7, #12]
 d82:	701a      	strb	r2, [r3, #0]
        p_dst++;
 d84:	68fb      	ldr	r3, [r7, #12]
 d86:	3301      	adds	r3, #1
 d88:	60fb      	str	r3, [r7, #12]
        p_src++;
 d8a:	68bb      	ldr	r3, [r7, #8]
 d8c:	3301      	adds	r3, #1
 d8e:	60bb      	str	r3, [r7, #8]
    while (*p_src != '\0') {
 d90:	68bb      	ldr	r3, [r7, #8]
 d92:	781b      	ldrb	r3, [r3, #0]
 d94:	2b00      	cmp	r3, #0
 d96:	d1f1      	bne.n	d7c <easy_strcpy+0x14>
    }
    *p_dst = '\0';
 d98:	68fb      	ldr	r3, [r7, #12]
 d9a:	2200      	movs	r2, #0
 d9c:	701a      	strb	r2, [r3, #0]

    return 0;
 d9e:	2300      	movs	r3, #0
}
 da0:	4618      	mov	r0, r3
 da2:	3714      	adds	r7, #20
 da4:	46bd      	mov	sp, r7
 da6:	bc80      	pop	{r7}
 da8:	4770      	bx	lr
 daa:	bf00      	nop

00000dac <test>:
int test()
{
 dac:	b480      	push	{r7}
 dae:	af00      	add	r7, sp, #0
    return 0;
 db0:	2300      	movs	r3, #0
}
 db2:	4618      	mov	r0, r3
 db4:	46bd      	mov	sp, r7
 db6:	bc80      	pop	{r7}
 db8:	4770      	bx	lr
 dba:	0000      	movs	r0, r0
 dbc:	6c6c6548 	.word	0x6c6c6548
 dc0:	6f43206f 	.word	0x6f43206f
 dc4:	78657472 	.word	0x78657472
 dc8:	000a4d20 	.word	0x000a4d20

00000dcc <UART0DR>:
 dcc:	4000c000                                ...@

00000dd0 <hex_asc_table>:
 dd0:	33323130 37363534 62613938 66656463     0123456789abcdef

00000de0 <upper_hex_asc_table>:
 de0:	33323130 37363534 42413938 46454443     0123456789ABCDEF

00000df0 <hex_weight_value_table>:
 df0:	00000001 0000000a 00000064 000003e8     ........d.......
 e00:	00002710 000186a0 000f4240 00989680     .'......@B......
 e10:	05f5e100                                ....
